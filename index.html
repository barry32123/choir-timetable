<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>St. Mary’s Forane Church Choir Timetable Generator</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; max-width: 900px; }
  button { font-size: 1.1em; padding: 8px 15px; }
  pre { background: #f0f0f0; padding: 15px; white-space: pre-wrap; max-height: 500px; overflow-y: auto; }
  #log { margin-top: 30px; border-top: 2px solid #ccc; padding-top: 20px; }
</style>
</head>
<body>

<h1>St. Mary’s Forane Church Choir Timetable Generator</h1>

<button id="generateBtn">Generate Timetable</button>
<button id="copyBtn">Copy Timetable to Clipboard</button>

<h2>Generated Timetable:</h2>
<pre id="output"></pre>

<h2>Generation Log:</h2>
<pre id="log"></pre>

<script>
(() => {
  // Members lists
  const males = ['seby', 'sebastian', 'roy', 'phijo', 'shaji', 'robert', 'don', 'aibel', 'atul'];
  const females = ['anu', 'angel', 'jemcy', 'sini', 'priya', 'dona', 'soyal', 'jincy', 'biji', 'christy', 'sneha'];
  const keyboardists = ['abraham sn', 'abraham jr', 'davis', 'sebastian', 'shaji']; // Sebastian & Shaji hybrids

  // Hybrid members who do both singing and keyboard
  const hybrids = ['sebastian', 'shaji'];

  // Mass timings per day (string times for easy match)
  const massSchedule = {
    monday:    ['5:30', '7:00'],
    tuesday:   ['5:30', '7:00'],
    wednesday: ['5:30', '7:00'],
    thursday:  ['5:30', '7:00'],
    friday:    ['5:30', '7:00', '10:00', '17:30'],
    saturday:  ['5:30', '7:00'],
    sunday:    ['5:30', '7:00', '10:00', '17:00'],
  };

  // Keyboard mass times per day
  const keyboardMasses = {
    friday: ['7:00', '10:00', '17:30'],
    saturday: ['7:00'],
    sunday: ['7:00', '10:00', '17:00'],
  };

  // Members NOT available for Friday 10:00 mass
  const fri10amUnavailable = new Set([
    'atul', 'aibel', 'angel', 'sneha', 'soyal', 'christy', 'dona',
    'abraham jr', 'abraham sn', 'jemcy'
  ]);

  // Members ONLY available for 5:30 AM masses (partial availability)
  const earlyMassPrefer = new Set(['seby', 'jincy', 'biji']);

  // Track assignments per day and member to avoid duplicates
  // Format: { day: { memberName: true } }
  let dailyAssignments;

  // Track total early mass assignments for preferred early mass members for ratio
  let earlyMassCounter;

  // Track keyboard assignments for hybrids (max once per week)
  let hybridKeyboardCount;

  // Store last generated timetable and logs
  let generationLog = [];

  // Utility: capitalize day names for output
  function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

  // Clear/reset global trackers
  function resetTrackers() {
    dailyAssignments = {};
    earlyMassCounter = { 'seby': 0, 'jincy': 0, 'biji': 0, totalEarlyMasses: 0 };
    hybridKeyboardCount = { 'sebastian': 0, 'shaji': 0 };
    // Initialize dailyAssignments days
    for (const day of Object.keys(massSchedule)) {
      dailyAssignments[day] = {};
    }
  }

  // Check if a member is assigned already this day
  function canAssign(member, day) {
    return !dailyAssignments[day][member];
  }

  // Assign a member to the day (only mark assigned)
  function assignMember(member, day) {
    dailyAssignments[day][member] = true;
  }

  // Check if keyboard mass for that day/time
  function isKeyboardMass(day, time) {
    return keyboardMasses[day] && keyboardMasses[day].includes(time);
  }

  // Shuffle an array (Fisher-Yates)
  function shuffle(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
  }

  // Select keyboardist for given mass (limit hybrids to once/week)
  function selectKeyboard(day, time) {
    // Priority keyboardists (Abraham Sn, Abraham Jr, Davis)
    const priority = ['abraham sn', 'abraham jr', 'davis'];

    // Filter available keyboardists who can be assigned and are not assigned today
    let available = keyboardists.filter(kb => canAssign(kb, day));

    // Exclude Sebastian and Shaji if they already assigned once as keyboard this week
    available = available.filter(kb => {
      if (hybrids.includes(kb)) {
        return hybridKeyboardCount[kb] < 1;
      }
      return true;
    });

    // Give priority members first
    let chosen = null;

    for (const p of priority) {
      if (available.includes(p)) {
        chosen = p;
        break;
      }
    }
    if (!chosen) {
      // Pick any from remaining available
      chosen = available.length > 0 ? available[0] : null;
    }
    if (chosen) {
      assignMember(chosen, day);
      if (hybrids.includes(chosen)) hybridKeyboardCount[chosen]++;
    }
    return chosen;
  }

  // Assign singers for a given mass time & day with strict rules
  function selectSingers(day, time) {
    // Exclude keyboardists who only sing for non-keyboard masses (they can be in singers)
    // Only keyboardists who also sing are Sebastian and Shaji (hybrids)
    // keyboardists who are hybrids get assigned here on non-keyboard masses as singers.

    // Filter males/females available and not assigned today
    let malesAvailable = males.filter(m => canAssign(m, day));
    let femalesAvailable = females.filter(f => canAssign(f, day));

    // Remove from Friday 10am unavailable
    if (day === "friday" && time === "10:00") {
      malesAvailable = malesAvailable.filter(m => !fri10amUnavailable.has(m));
      femalesAvailable = femalesAvailable.filter(f => !fri10amUnavailable.has(f));
    }

    // Helper to check early morning masses for Mon-Thu & Sat
    const isEarlyMass = ((time === "5:30" || time === "7:00") &&
      (["monday", "tuesday", "wednesday", "thursday", "saturday"].includes(day)));

    // Check if special mass requiring 2M2F exactly
    const isSpecialMass =
      (day === "friday" && (time === "7:00" || time === "17:30")) ||
      (day === "sunday" && time === "7:00");

    let selectedMales = [];
    let selectedFemales = [];

    if (isSpecialMass) {
      // Strict 2 males + 2 females
      if (malesAvailable.length < 2 || femalesAvailable.length < 2) {
        // Not enough members, just assign what is available
        selectedMales = malesAvailable.slice(0, Math.min(2, malesAvailable.length));
        selectedFemales = femalesAvailable.slice(0, Math.min(2, femalesAvailable.length));
      } else {
        // Pick first 2 males and 2 females fairly
        selectedMales = malesAvailable.slice(0, 2);
        selectedFemales = femalesAvailable.slice(0, 2);
      }
    } else if (isEarlyMass) {
      // For early mass Mon-Thu & Sat 5:30/7am:
      // 2 or 3 singers allowed, ratios allowed: 1m1f or 1m2f (NO 2m1f)
      // Seby, Jincy, Biji to get ~50-60% assignments in early masses
      // But others rotate fairly as well

      // Count how many early masses assigned so far for each preferred member
      const totalEarly = earlyMassCounter.totalEarlyMasses || 1; // Avoid div by zero

      // Filter preferred early mass members available
      let preferredMales = malesAvailable.filter(m => earlyMassPrefer.has(m));
      let preferredFemales = femalesAvailable.filter(f => earlyMassPrefer.has(f));

      // We want to assign Seby, Jincy, Biji in about half the early masses total
      // but others also get chances.

      // Strategy:
      // If we have available preferred males/females and they have less than 60% assignments,
      // pick them first, else pick others.

      // First pick male singer
      let maleChosen = null;
      for (const m of malesAvailable) {
        if (earlyMassPrefer.has(m)) {
          // Check if assigned less than 60%
          if ((earlyMassCounter[m] / totalEarly) < 0.6 && canAssign(m, day)) {
            maleChosen = m;
            break;
          }
        }
      }
      if (!maleChosen && malesAvailable.length > 0) {
        maleChosen = malesAvailable[0];
      }

      // First pick female singers
      let femaleChosen = [];

      // Try preferred females first for 2 spots max
      for (const f of femalesAvailable) {
        if (femaleChosen.length >= 2) break;
        if (earlyMassPrefer.has(f) && (earlyMassCounter[f] / totalEarly) < 0.6) {
          femaleChosen.push(f);
        }
      }
      // If less than 1 female chosen, fill from others
      if (femaleChosen.length < 1) {
        const others = femalesAvailable.filter(f => !earlyMassPrefer.has(f));
        for (const f of others) {
          if (femaleChosen.length >= 2) break;
          femaleChosen.push(f);
        }
      }
      // Make sure at least 1 female is selected (for ratio 1m1f)
      if (femaleChosen.length === 0 && femalesAvailable.length > 0) {
        femaleChosen.push(femalesAvailable[0]);
      }

      // Now ensure ratio: 1m1f or 1m2f only (no 2m1f)
      // If 3 singers, must be 1 male + 2 females
      // We allow 2 or 3 singers here, so pick femaleChosen length accordingly
      if (femaleChosen.length > 2) femaleChosen = femaleChosen.slice(0, 2);

      // Now assign chosen
      if (maleChosen && canAssign(maleChosen, day)) selectedMales.push(maleChosen);
      for (const f of femaleChosen) {
        if (canAssign(f, day)) selectedFemales.push(f);
      }

      // Update earlyMassCounter for preferred members assigned
      earlyMassCounter.totalEarlyMasses++;
      if (maleChosen && earlyMassPrefer.has(maleChosen)) earlyMassCounter[maleChosen]++;
      for (const f of selectedFemales) {
        if (earlyMassPrefer.has(f)) earlyMassCounter[f]++;
      }

    } else {
      // Normal mass with 2 or 3 singers, no special restrictions on ratio other than NO 2m1f

      // Pick 2 males and 2 females if possible (preferred)
      if (malesAvailable.length >= 2 && femalesAvailable.length >= 2) {
        selectedMales = malesAvailable.slice(0, 2);
        selectedFemales = femalesAvailable.slice(0, 2);
      } else if (malesAvailable.length >= 1 && femalesAvailable.length >= 1) {
        selectedMales = malesAvailable.slice(0, 1);
        selectedFemales = femalesAvailable.slice(0, 1);
      } else {
        // Fallback
        selectedMales = malesAvailable.slice(0, 1);
        selectedFemales = femalesAvailable.slice(0, 1);
      }
    }

    // Final check for ratio: no 2m1f allowed anywhere
    if (selectedMales.length === 2 && selectedFemales.length === 1) {
      // Adjust by adding another female if possible or reduce male
      if (femalesAvailable.length > 1) {
        selectedFemales.push(femalesAvailable[1]);
      } else if (selectedMales.length > 1) {
        selectedMales.pop();
      }
    }

    // Mark assigned members for the day
    selectedMales.forEach(m => assignMember(m, day));
    selectedFemales.forEach(f => assignMember(f, day));

    return { males: selectedMales, females: selectedFemales };
  }

  // Generate timetable for the week
  function generateTimetable() {
    resetTrackers();
    generationLog = [];

    let timetable = {};

    for (const day of Object.keys(massSchedule)) {
      timetable[day] = {};

      for (const time of massSchedule[day]) {
        timetable[day][time] = { singers: { males: [], females: [] }, keyboard: null };

        // Keyboard assignment only on keyboard mass times
        let keyboardist = null;
        if (isKeyboardMass(day, time)) {
          keyboardist = selectKeyboard(day, time);
          timetable[day][time].keyboard = keyboardist;
          generationLog.push(`${capitalize(day)} ${time} Keyboard: ${keyboardist || "None available"}`);
        }

        // Select singers for all masses except keyboard only ones? No, singers always assigned
        let singers = selectSingers(day, time);
        timetable[day][time].singers = singers;
        generationLog.push(`${capitalize(day)} ${time} Singers: Males: [${singers.males.join(", ")}], Females: [${singers.females.join(", ")}]`);
      }
    }
    return timetable;
  }

  // Format timetable nicely
  function formatTimetable(timetable) {
    let output = "";
    for (const day of Object.keys(timetable)) {
      output += `${capitalize(day)}:\n`;
      for (const time of Object.keys(timetable[day])) {
        const entry = timetable[day][time];
        output += `  ${time} - Keyboard: ${entry.keyboard || "None"}, Singers: M(${entry.singers.males.join(", ") || "None"}), F(${entry.singers.females.join(", ") || "None"})\n`;
      }
      output += "\n";
    }
    return output;
  }

  // Format log
  function formatLog() {
    return generationLog.join("\n");
  }

  // Generate button event
  document.getElementById("generateBtn").addEventListener("click", () => {
    const timetable = generateTimetable();
    document.getElementById("output").textContent = formatTimetable(timetable);
    document.getElementById("log").textContent = formatLog();
  });

  // Copy to clipboard button event
  document.getElementById("copyBtn").addEventListener("click", () => {
    const outputText = document.getElementById("output").textContent;
    navigator.clipboard.writeText(outputText).then(() => {
      alert("Timetable copied to clipboard!");
    });
  });

})();
</script>

</body>
</html>
